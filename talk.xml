<presentation>
  <title>Git - Revision control for humans</title>
  <subtitle>This work is licensed under a Creative Commons Attribution 3.0 License. (http://creativecommons.org/licenses/by/3.0)</subtitle>
  <author>Catalyst IT Ltd</author>

<!--

  <slide>
    <title>Title Here</title>
    <screenshot>filename.png</screenshot>
    <image src="file.jpg" />
    <bullet></bullet>
    <code syntax="perl"><![CDATA[
    ]]></code>
    <notes>
    </notes>
  </slide>

-->

  <slide>
    <title>Overview</title>
    <bullet>Why use revision control?</bullet>
    <bullet>Why use git?</bullet>
    <bullet>Managing your files</bullet>
    <bullet>Branching</bullet>
    <bullet>Merging</bullet>
    <bullet>Remote repositories</bullet>
    <notes>
    </notes>
  </slide>

  <slide>
    <title>Why use revision control?</title>
    <bullet>Track changes (to almost anything)</bullet>
    <bullet>View history</bullet>
    <bullet>Look back to find when bugs were created</bullet>
    <bullet>Find the reasoning behind why something is how it is</bullet>
    <bullet>Roll back changes</bullet>
    <bullet>Apply kudos for effort</bullet>
    <bullet>Backups of your important stuff</bullet>
    <notes>
    Without revision control you end up with countless copies of files with no idea what is what.  Anecdote - files called readme.tt, readme.ttt, readme.tttt
    </notes>
  </slide>

  <slide>
    <title>What options are there?</title>
    <bullet>Lots of options...</bullet>
    <pause />
    <bullet>RCS</bullet>
    <bullet>CVS</bullet>
    <bullet>Subversion</bullet>
    <bullet>Darcs</bullet>
    <bullet>Perforce</bullet>
    <bullet>Bzr</bullet>
    <bullet>...</bullet>
    <notes>
    </notes>
  </slide>

  <slide>
    <title>Why should you use git?</title>
    <bullet>It is fast</bullet>
    <bullet>Branching is trivial</bullet>
    <bullet>Merging of branches actually makes sense</bullet>
    <bullet>You can be disconnected from the network, yet still continue working</bullet>
    <bullet>It does not dictate your workflow</bullet>
    <bullet>Data Assurance <link>http://git-scm.com/about/info-assurance</link></bullet>
    <bullet>Once you master the concepts, you can do some really creative (and useful!) stuff</bullet>
    <bullet>The cool kids use it</bullet>
  </slide>

  <slide>
    <title>Installing</title>
    <code>
# Required
sudo aptitude install git-core
    </code>
    <code>
# Recommended
sudo aptitude install gitk
    </code>
    <code>
# See also...
sudo aptitude search git
    </code>
    <notes>
    </notes>
  </slide>

  <slide>
    <title>Configuring</title>
    <bullet>Global data is stored in <tt>$HOME/.gitconfig</tt></bullet>
    <bullet>Project data is stored in <tt>$PROJECT/.git/config</tt></bullet>
    <bullet>use <tt>git config</tt> to see and modify it</bullet>
    <bullet>..or <tt>vim</tt></bullet>
    <bullet>But you don't have to do this</bullet>
    <notes>
    </notes>
  </slide>

  <slide>
    <title>Configuring - For convenience</title>
    <code>
train@train:~$ git config --global user.name "Your Name"
train@train:~$ git config --global user.email "null@catalyst.net.nz"
    </code>
    <code>
train@train:~$ git config --global core.editor nano
    </code>
    <notes>
    </notes>
  </slide>

  <slide>
    <title>Some concepts to begin with</title>
    <bullet><tt>git</tt> is just a bit different from other revision control systems</bullet>
    <screenshot>local-remote-small.png</screenshot>
    <bullet>You get a <tt>working directory</tt> - so you can work with your project</bullet>
    <bullet>You get an <tt>staging area</tt>, which can be used to prepare commits</bullet>
    <bullet>You get a <tt>local repository</tt>,  which will hold all your commits</bullet>
    <bullet>The local repository can be aware of multiple branches</bullet>
    <bullet>Some branches are <tt>remote</tt></bullet>
  </slide>

  <slide>
    <title>Create a new repository</title>
    <bullet>Use <tt>git init</tt></bullet>
    <code>
train@train:~$ mkdir /tmp/test
train@train:~$ cd /tmp/test
train@train:/tmp/test$ git init
Initialized empty Git repository in .git/
train@train:/tmp/test$ 
    </code>
    <bullet>Check the status with <tt>git status</tt></bullet>
    <code>
train@train:/tmp/test$ git status
# On branch master
#
# Initial commit
#
nothing to commit (create/copy files and use "git add" to track)
train@train:/tmp/test$ 
    </code>
    <notes>
    </notes>
  </slide>

  <slide>
    <title>Managing Files - Add</title>
    <bullet>Make some changes...</bullet>
    <code>
train@train:/tmp/test$ touch super-script.pl
    </code>
    <code>
train@train:/tmp/test$ git status
# On branch master
#
# Initial commit
#
# Untracked files:
#   (use "git add &lt;file>..." to include in what will be committed)
#
#	super-script.pl
nothing added to commit but untracked files present (use "git add" to track)
    </code>
    <bullet>Tell git about files with <tt>git add &lt;files></tt></bullet>
    <code>
train@train:/tmp/test$ git add super-script.pl 
    </code>
    <code>
train@train:/tmp/test$ git status
# On branch master
#
# Initial commit
#
# Changes to be committed:
#   (use "git rm --cached &lt;file>..." to unstage)
#
#       new file: super-script.pl
#
train@train:/tmp/test$ 
    </code>
    <notes>
    </notes>
  </slide>

  <slide>
    <title>Managing Files - Change an existing file</title>
    <bullet>Make some changes...</bullet>
    <code>
train@train:/tmp/test$ echo DATA > super-script.pl
    </code>
    <code>
train@train:/tmp/test$ git status
# On branch master
#
# Initial commit
#
# Changes to be committed:
#   (use "git rm --cached &lt;file>..." to unstage)
#
#	new file:   super-script.pl
#
# Changed but not updated:
#   (use "git add &lt;file>..." to update what will be committed)
#   (use "git checkout -- &lt;file>..." to discard changes in working directory)
#
#	modified:   super-script.pl
#
    </code>
    <bullet>...so, git is saying that it knows you have changed the file since you added it</bullet>
    <bullet>I.e. The version in the checkout is different to the version in the index</bullet>
    <bullet>We need to tell git that you intend to commit the checked out version, with <tt>git add &lt;files></tt></bullet>
    <code>
train@train:/tmp/test$ git add super-script.pl 
    </code>
    <code>
train@train:/tmp/test$ git status
# On branch master
#
# Initial commit
#
# Changes to be committed:
#   (use "git rm --cached &lt;file>..." to unstage)
#
#	new file:   super-script.pl
#
    </code>
    <notes>
    </notes>
  </slide>

  <slide>
    <title>Committing changes</title>
    <bullet>We have told git about our changes</bullet>
    <bullet>We haven't actually committed anything yet</bullet>
    <bullet>This is deliberate - so you can build up more complex commits</bullet>
    <bullet>Every change needs to be committed</bullet>
    <bullet>Commit with <tt>git commit &lt;files></tt></bullet>
    <bullet>You will be stuck in an editor so you can input a commit message </bullet>
    <bullet>NORMALLY, you will make your commit message meaningful</bullet>
    <code>
train@train:/tmp/test$ git commit super-script.pl 
Created commit ae54011: Add a message.
 1 files changed, 3 insertions(+), 0 deletions(-)
 create mode 100644 super-script.pl
train@train:/tmp/test$ 
    </code>
    <notes>
    </notes>
  </slide>

  <slide>
    <title>Committing changes - some useful options</title>
    <bullet>You don't <tt>have</tt> to add all your changes manually</bullet>
    <code>
train@train:/tmp/test$ git commit &lt;file>
    </code>
    <code>
train@train:/tmp/test$ git commit -a
    </code>
    <bullet>You can have an easier editor...</bullet>
    <code>
train@train:/tmp/test$ EDITOR=gedit git commit -a
    </code>
    <bullet>You don't have to use an editor at all...</bullet>
    <code>
train@train:/tmp/test$ git commit -m 'commit message goes here'
    </code>
    <notes>
    </notes>
  </slide>

  <slide>
    <title>Managing Files - Permissions</title>
    <bullet>Oops, that file isn't executable</bullet>
    <code>
train@train:/tmp/test$ chmod 755 super-script.pl 
train@train:/tmp/test$ git commit super-script.pl 
Created commit 378af93: Make it executable.
 0 files changed, 0 insertions(+), 0 deletions(-)
 mode change 100644 => 100755 super-script.pl
train@train:/tmp/test$ 
    </code>
    <notes>
    </notes>
  </slide>


  <slide>
    <title>Managing Files - Move</title>
    <bullet>To rename a file use <tt>git mv &lt;source> &lt;dest></tt></bullet>
    <code>
train@train:/tmp/test$ git mv super-script.pl silly-script.pl
    </code>
    <code>
train@train:/tmp/test$ git status
# On branch master
# Changes to be committed:
#   (use "git reset HEAD &lt;file>..." to unstage)
#
#       renamed:    super-script.pl -> silly-script.pl
#
train@train:/tmp/test$ 
    </code>
    <bullet>This has changed our checkout, and the index, so we are ready to commit the change</bullet>
    <code>
train@train:/tmp/test$ git commit
Created commit fabd446: Rename the file.
 1 files changed, 0 insertions(+), 0 deletions(-)
 rename super-script.pl => silly-script.pl (100%)
train@train:/tmp/test$ 
    </code>
    <notes>
    </notes>
  </slide>

  <slide>
    <title>Managing Files - Delete</title>
    <bullet>To delete a file use <tt>git rm &lt;files></tt></bullet>
    <code>
# This won't actually work, because we haven't created "another-script.pl"
# ... but you can try it, if you like....
train@train:/tmp/test$ git rm -f another-script.pl 
    </code>
    <code>
train@train:/tmp/test$ git status
# On branch master
# Changes to be committed:
#   (use "git reset HEAD &lt;file>..." to unstage)
#
#       deleted:    another-script.pl
#
train@train:/tmp/test$ 
    </code>
    <bullet>And commit the change</bullet>
    <code>
train@train:/tmp/test$ git commit
Created commit bd10c5f: Remove another-script.pl
 0 files changed, 0 insertions(+), 0 deletions(-)
 delete mode 100644 another-script.pl
train@train:/tmp/test$ 
    </code>
    <notes>
    </notes>
  </slide>

  <slide>
    <title>Change Logs</title>
    <bullet>See what is going on</bullet>
    <bullet>Use <tt>git log</tt></bullet>
    <bullet>By default the output is piped into $PAGER</bullet>
    <code>
    <![CDATA[
train@train:/tmp/test$ git log
commit 09f90bc2a74f7ca2f825c4a386e168649b9fec97
Author: Evan Giles <evan@catalyst.net.nz>
Date:   Thu Dec 16 11:53:48 2010 +1300

    Rename the file.

commit f7123c5ffdccbed11b50b0b74a181186e1a13028
Author: Evan Giles <evan@catalyst.net.nz>
Date:   Thu Dec 16 11:53:25 2010 +1300

    Make it executable

commit 8657bea3230587abdcbe39e6bf699c9ee8f505a6
Author: Evan Giles <evan@catalyst.net.nz>
Date:   Thu Dec 16 11:52:51 2010 +1300

    Add a message.
train@train:/tmp/test$ 
    ]]>
    </code>
    <notes>
    </notes>
  </slide>

  <slide>
    <title>Change Logs</title>
    <bullet>Can specify a file or directory</bullet>
<code>
train@train:/tmp/test$ git log silly-script.pl 
</code>
    <notes>
    </notes>
  </slide>

  <slide>
    <title>Change Logs - Annotate</title>
    <bullet>Show who made changes to what line</bullet>
    <bullet>Also known as the blame log</bullet>
<code>
train@train:/tmp/test$ git blame silly-script.pl
train@train:/tmp/test$ git blame silly-script.pl  | cat
^ae54011 super-script.pl (Andrew Ruthven 2008-05-09 17:01:41 +1200 1) #!/usr/bin/perl -w
^ae54011 super-script.pl (Andrew Ruthven 2008-05-09 17:01:41 +1200 2) 
^ae54011 super-script.pl (Andrew Ruthven 2008-05-09 17:01:41 +1200 3) print "silly script\n";
2c08faf4 silly-script.pl (Bad Coder      2008-05-09 17:18:18 +1200 4) I'm in ur code, breaking ur stuff.
train@train:/tmp/test$ 
</code>
    <bullet>Who is this Bad Coder fella?</bullet>
    <notes>
    </notes>
  </slide>

  <slide>
    <title>Change Logs - GUI</title>
    <bullet>Not strictly change logs, but...  gitk / qgit / gitg / etc</bullet>
    <screenshot>gitk.png</screenshot>
  </slide>

  <slide>
    <title>Some more concepts - commits</title>
    <bullet>It is important to understand that git thinks in <tt>commits</tt></bullet>
    <bullet>Each commit refers to a previous commit (its parent)</bullet>
    <bullet> - and a series of commits provides a complete history of the project</bullet>
    <bullet><tt>gitk</tt> lets you visualise the commit history, which helps a lot</bullet>
    <bullet>Commits can be referenced by their SHA1 checksum</bullet>
    <bullet> - or an abbreviation of it</bullet>
    <bullet> - or by a number of things that might refer to them</bullet>
    <bullet>Commits are totally unchangeable</bullet>
    <pause/>
    <bullet>Commits are TOTALLY unchangeable</bullet>
    <pause/>
    <bullet>Commits are TOTALLY UNCHANGEABLE</bullet>
  </slide>

  <slide>
    <title>Branching - List</title>
    <bullet>To show branches use <tt>git branch</tt></bullet>
<code>
train@train:/tmp/test$ git branch
* master
train@train:/tmp/test$ 
</code>
    <bullet>Only one branch, called <tt>master</tt></bullet>
    <bullet>The '*' indicates that it is your current branch</bullet>
  </slide>

  <slide>
    <title>Branching - Create</title>
    <bullet>Use <tt>git branch &lt;new-name></tt></bullet>
    <bullet>or <tt>git checkout -b &lt;new-name></tt></bullet>
<code>
train@train:/tmp/test$ git checkout -b new-branch
Switched to a new branch "new-branch"
train@train:/tmp/test$ git branch
  master
* new-branch
train@train:/tmp/test$ 
</code>
    <bullet>Will create "new-branch", and check it out for you </bullet>
    <bullet>new-branch will be created at the commit you previously had checked out</bullet>
    <bullet>Can also create a new branch at another location</bullet>
<code>
train@train:/tmp/test$ git checkout -b another-branch master
Switched to a new branch "another-branch"
train@train:/tmp/test$ git branch
* another-branch
  master
  new-branch
train@train:/tmp/test$ 
</code>
  </slide>

  <slide>
    <title>Branching - Change Branch</title>
    <bullet>Use <tt>git checkout</tt></bullet>
<code>
train@train:/tmp/test$ git checkout new-branch
Switched to branch "new-branch"
train@train:/tmp/test$ git branch
  another-branch
  master
* new-branch
train@train:/tmp/test$ 
</code>
    <bullet>Don't forget to see how this is shown in <tt>gitk</tt></bullet>
  </slide>

  <slide>
    <title>Branching - What's the deal?</title>
    <bullet>You can make commits on a branch without polluting other branches</bullet>
<code>
train@train:/tmp/test$ echo "# From new-branch" >> silly-script.pl 
train@train:/tmp/test$ git commit silly-script.pl 
Created commit a6ed2cf: From new-branch
 1 files changed, 1 insertions(+), 0 deletions(-)
train@train:/tmp/test$ 
</code>
    <bullet>Check the file, then jump to another branch, the text we added ain't there</bullet>
    <code>
train@train:/tmp/test$ cat silly-script.pl 
DATA
# From new-branch
train@train:/tmp/test$ git checkout master
Switched to branch "master"
train@train:/tmp/test$ cat silly-script.pl 
DATA
train@train:/tmp/test$ 
    </code>
  </slide>

  <slide>
    <title>Branching - Why?</title>
    <bullet>Many (most) projects have a branch for each release</bullet>
    <bullet>Branches are useful for experimental features / refactoring</bullet>
    <bullet>Branches happen (without even trying) when several people try to work on the same project - but I'll explain that soon ;)</bullet>
  </slide>

  <slide>
    <title>Merging - Simple Case</title>
    <bullet>You should now be on the master branch</bullet>
    <code>
train@train:/tmp/test$ git status
# On branch master
nothing to commit (working directory clean)
train@train:/tmp/test$ 
    </code>
    <bullet>Just say <tt>git merge &lt;other branch></tt></bullet>
    <code>
train@train:/tmp/test$ git merge new-branch
Updating e766bfb..a6ed2cf
Fast forward
 silly-script.pl |    1 +
 1 files changed, 1 insertions(+), 0 deletions(-)
train@train:/tmp/test$ 
    </code>
    <bullet>In this case, we have done a <tt>fast forward</tt> commit</bullet>
    <bullet>If there are no conflicts, this may make a new commit object</bullet>
    <bullet>use <tt>gitk</tt> to see what happened</bullet>
  </slide>

  <slide>
    <title>Merging - With conflicts</title>
    <bullet>Conflicts are more difficult (lets create one)</bullet>
    <code>
train@train:/tmp/test$ echo "New value for data" > silly-script.pl
train@train:/tmp/test$ git commit -a -m 'update script with a new value'
train@train:/tmp/test$ git checkout new-branch
train@train:/tmp/test$ echo "different value for data" > silly-script.pl
train@train:/tmp/test$ git commit -a -m 'update script with a different value'
train@train:/tmp/test$ git checkout master
    </code>
    <bullet>If there are conflicts then git will stop and make you fix it.</bullet>
    <code>
train@train:/tmp/test$ git merge new-branch
Auto-merged silly-script.pl
CONFLICT (content): Merge conflict in silly-script.pl
Automatic merge failed; fix conflicts and then commit the result.
train@train:/tmp/test$ cat silly-script.pl 
&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD:silly-script.pl
New value for data
=======
different value for data
>>>>>>> new-branch:silly-script.pl
train@train:/tmp/test$ 
    </code>
  </slide>

  <slide>
    <title>Merging - Fixing conflicts</title>
    <bullet>Lots of tools to help fix things up.  Hand edit, xxdiff, smartmerge, etc</bullet>
    <bullet>We'll fix it by editing the file</bullet>
    <code>
train@train:/tmp/test$ vi silly-script.pl 
train@train:/tmp/test$ cat silly-script.pl 
New, different value for data
    </code>
    <bullet>But git still won't allow us to continue...</bullet>
    <code>
train@train:/tmp/test$ git commit
U	silly-script.pl
fatal: 'commit' is not possible because you have unmerged files.
Please, fix them up in the work tree, and then use 'git add/rm &lt;file>' as
appropriate to mark resolution and make a commit, or use 'git commit -a'.
train@train:/tmp/test$ 
    </code>
    <bullet>We need to tell git that it has been fixed before we commit</bullet>
    <code>
train@train:/tmp/test$ git add silly-script.pl 
train@train:/tmp/test$ git commit
Created commit a411f2a: Merge branch 'new-branch'
train@train:/tmp/test$ 
    </code>
    <bullet>In this case the commit message is automatically created, but you can edit it</bullet>
    <code>
Merge branch 'new-branch'

Conflicts:

        silly-script.pl

    </code>
  </slide>

  <slide>
    <title>Merging - How does it look?</title>
    <bullet>Looking at the trees in gitk helps you understand stuff.</bullet>
    <code>
gitk
    </code>
  </slide>

  <slide>
    <title>Ways to work with git (1)</title>
    <bullet>Corporate Workflow</bullet>
    <screenshot>workflow-a.png</screenshot>
    <bullet>Catalyst uses this a lot</bullet>
    <bullet>You will use this</bullet>
  </slide>

  <slide>
    <title>Ways to work with git (2)</title>
    <bullet>Integration Manager Workflow</bullet>
    <screenshot>workflow-b.png</screenshot>
    <bullet>A quick diversion: http://www.github.com</bullet>
  </slide>

  <slide>
    <title>Ways to work with git (3)</title>
    <bullet>Dictator Workflow</bullet>
    <screenshot>workflow-c.png</screenshot>
    <bullet>This is how the Linux kernel is managed</bullet>
  </slide>

  <slide>
    <title>Ways to work with git (4)</title>
    <bullet>Peer to peer Workflow</bullet>
    <screenshot>workflow-d.png</screenshot>
  </slide>

  <slide>
    <title>Sharing your changes with others</title>
    <screenshot>local-remote.png</screenshot>
  </slide>

  <slide>
    <title>A gentle recommendation...</title>
    <bullet>git push</bullet>
    <bullet>git fetch</bullet>
    <bullet><del>git pull</del> git fetch; git merge</bullet>
  </slide>

  <slide>
    <title>Creating Repositories - Revisited</title>
    <bullet>There are many different ways to get repositories, some are:</bullet>
    <bullet>Create a new one (we've already covered this)</bullet>
    <code>
train@train:/tmp/test$ git init
Initialized empty Git repository in .git/
train@train:/tmp/test$ 
    </code>
    <bullet>In practise, you're more likely to use <tt>git clone &lt;URL></tt></bullet>
    <bullet>To check out the source code of a random project</bullet>
    <code>
cd /tmp
train@train:/tmp$ git clone http://git.catalyst.net.nz/git.git
Cloning into git...
remote: Counting objects: 90, done.
remote: Compressing objects: 100% (43/43), done.
remote: Total 90 (delta 44), reused 90 (delta 44)
Receiving objects: 100% (90/90), 31.62 KiB, done.
Resolving deltas: 100% (44/44), done.
train@train:/tmp$ 
    </code>
    <code>
train@train:/tmp$ cd git
train@train:/tmp/git$ ls 
train@train:/tmp/git$ gitk 
    </code>
  </slide>

  <slide>
    <title>Remote repositories - URLs </title>
    <bullet>Clone an existing repository via HTTP</bullet>
<code>
train@train:/tmp$ git clone http://gitprivate.catalyst.net.nz/git-training-example.git
</code>
    <bullet>Clone an existing repository via SSH</bullet>
<code>
train@train:/tmp$ git clone git+ssh://git.catalyst.net.nz/git/private/git-training-example.git
</code>
    <bullet>Clone an existing repository Local repository (this is just a bit mad)</bullet>
<code>
train@train:/tmp$ git clone test test2
</code>
  </slide>

  <slide>
    <title>What else do you have to understand about sharing with others?</title>
    <bullet>Once upon a time.... Alice and Bob wanted to do some work</bullet>
    <screenshot>lastthing1.png</screenshot>
  </slide>

  <slide>
    <title>What else do you have to understand about sharing with others?</title>
    <bullet>So they both made some changes....</bullet>
    <screenshot>lastthing2.png</screenshot>
  </slide>

  <slide>
    <title>What else do you have to understand about sharing with others?</title>
    <bullet>Alice pushed her changes...</bullet>
    <screenshot>lastthing3.png</screenshot>
  </slide>

  <slide>
    <title>A preview of the intermediate course :)</title>
    <bullet>git revert</bullet>
    <bullet>git cherrypick</bullet>
    <bullet>git tag</bullet>
    <bullet>git commit --amend</bullet>
    <bullet>git rebase</bullet>
    <bullet>git rebase --interactive</bullet>
    <bullet>git reset</bullet>
    <bullet>git stash</bullet>
    <bullet>Changes with gitk</bullet>
    <bullet>git-gui</bullet>
  </slide>

  <slide>
    <title>The End</title>
    <bullet>Questions?</bullet>
    <pause/>
    <bullet>http://www.github.com</bullet>
    <bullet>http://git-scm.com/about</bullet>
    <bullet>Data Assurance <link>http://git-scm.com/about/info-assurance</link></bullet>
    <notes>
    </notes>
  </slide>

</presentation>
